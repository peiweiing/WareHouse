# 函数的概念

函数就是把完成特定功能的一段代码抽象出来，使之成为程序中的一个独立实体，起个名字（函数名）。可以在同一个程序或其他程序中多次重复使用（通过函数名调用）。
	注：编写好的函数代码只有通过调用才会执行，不调用的时候不会执行。

函数的作用（好处）：
		1，使程序变得更简短而清晰
		2，有利于程序维护
		3，可以提高程序开发的效率 ,
		4，提高了代码的重用性(复用性)

## JS函数的声明

语法:
		 function 函数名([参数列表]){
			函数内的语句;
			[return 返回值;]
		 }
	例：打印99表
		function jiujiubiao(){	//函数名，圆括号内是参数列表
			for(var i=1;i<=9;i++){
				for(var j=1;j<=i;j++){
					document.write(i+"*"+j+"="+(i*j)+",");
				}
				document.write("<br/>");
			}//函数结尾无返回值
		}
	

通过函数名调用函数
	调用刚声明的打印99表的函数
	function test1(){

​	jiujiubiao();
​	}
​	当代码执行到调用函数时，就会转到函数声明去执行函数，执行完函数后返回继续执行后续代码。

要点：
		没有参数和返回值的函数，就像是在原来实现某功能的代码上加了盖。
		函数初学者，函数声明不要写在别的函数内。

## 有参数的函数

函数声明时在圆括号内编写参数列表，函数调用时在圆括号内填入需要函数处理的数据。这个时候的函数就
像是一台机器，声明的参数就是机器进料口，调用时候把需要加工的原材料（数据）放进了机器进料口。

例：调用这个判断奇偶的函数
			checkjiou(6);
			checkjiou(7);

判断奇偶
		function checkjiou(num1){
			if(num1%2==0){
				alert(num1+“是偶数”);
			}else{
				alert(num1+“是奇数”);
			}
		}

第一次调用把6传递给参数num1，第二次调用把7传递给参数num1。
	每次调用都会转到函数声明去完整的执行函数。
	函数声明时圆括号里的参数叫形参，仅表示函数需要数据。
	调用函数时圆括号里的数据叫实参，表示真正需要处理的数据。

## return

在函数内使用return语句返回函数执行的结果，我们在调用函数时用一个变量来接收函数返回的结果。
	当执行到return后，函数将直接退出，return后如果还有代码将不再执行。

return 只能返回一个值
	封装函数里，一般没有输出语句（alert，document.write）

例：加法
	函数的声明
		function mysum(num1,num2){
			return num1+num2;
		}
	函数的调用
		var sum1=mysum(3,5);

## JS函数的分类

函数分类： 
	 内置函数，是官方提供的函数，直接使用,如：alert()、Math.pow()等。 
 		isNaN()判断是不是数字。 
 		注：通过JS帮助文档可以查阅JS所有内置函数的使用。 
	 自定义函数： 
		 我们自己编写的函数。

## 匿名函数

函数可以当成值存储在变量里，通过变量名来调用，调用时必须加圆括号。 

var fun1=function(){alert("我是匿名函数");};	 //匿名函数声明 
	fun1(); 		//匿名函数调用 

var fun2=function(num1,num2){return num1+num2;}; 	//匿名函数声明 
	var num3=fun2(1,2); 	//匿名函数调用 
	alert(num3);

## 封装函数注意点

定义函数的注意点： 
	1、形参，不要在函数内部重新定义 
	2、函数内部尽量不要出现输出语句（alert，document.write）
	3、return后面只能出现一个值（即函数只能返回一个值）

## JS的编译和执行

javascript代码在运行时有预编译和执行两个阶段，在预编译阶段会对函数和变量进行处理，对所有的声明变量会赋值为undefined，对所有的声明函数也会赋值为函数的定义。
	在执行阶段会按照代码顺序，一行行的翻译并执行代码。

var myname;
	alert(myname);
	myname=“刘德华”;
	alert(myname);

## 变量的作用域

变量的作用域：就是变量起作用的范围。或者说有效范围。
		局部变量
			 局部变量就是定义在函数内部的变量，这个变量只能在函数内部使用，即作用域范围只是函数内部，另外，形参也是局部变量。
		全局变量
			 全局变量就是定义在函数外部的变量，这个变量在任何函数中都有效，即作用域范围是当前文件的任何地方。不但在任何函数中都可以使用，而且值是共享。即A函数改变值后，B函数拿到的就是改后的值。

var num1=1;			 //全局变量，作用域是当前文件
	function testf1(){
		var num2=0;		 //局部变量，作用域仅在当前函数中
		alert(num1);		 //1
		alert(num2); 		//0
	}
	function testf2(){
		alert(num1); 		//1
		alert(num2); 		//undefinde，
	}

## 变量的声明提升

变量的声明提升：变量声明总是会被解释器悄悄地被“提升”到方法体的最顶部请注意，变量赋值并没有被提升，只是声明被提升了。

var num1=1; 			//全局变量，作用域是当前文件
	function testf1(){
			num1=2; 		//局部变量，声明被提升
			var num1;
			alert(num1); 	//2
	}
	function testf2(){
			alert(num1); 	//全局变量1
	}

## 事件调用函数

事件调用函数：
		我们把事件和自定义函数建立起对应关系，当事件发生时就去调用我们的函数。
		我们已经学习了onclick事件，还有onload, onfocus、onblur等等。
		 onload:标签（页面）加载完成(页面完全打开)
		 onfocus:获得焦点（简单理解为，光标进入）
		 onblur:失去焦点（简单理解为，光标离开）

## 递归函数

JS函数可以相互调用，嵌套调用
	JS函数也能调用自己，调用自己的函数叫做递归函数，递归函数就是特殊的嵌套调用函数。



递归函数的调用是递的过程，递的是参数。

递归函数的返回过程是归的过程，归的是返回值。

## 编写递归函数

1，先用函数实现第一次的运算，假如num1=5，实现第一次运算就是5*4 num1*(num1-1)
		function nn(num1){
			return num1*(num1-1);
		}
	2，在函数内调用自己实现第二次运算，第二次运算就是4*3，调用原函数实现就是nn(4) nn(num1-1)
		function nn(num1){
			return num1*nn(num1-1);
		}
	3，第二步完成后基本递归框架已完成，最后编写退出递归的条件，当num1=1时就是计算的最后一步，直接返回1
		function nn(num1){
			if(num1==1){
				return 1;
			}
			return num1*nn(num1-1);
		}

## 斐波那契数列

斐波那契数列：1，1，2，3，5，8 。。。。从第三项开始每项都等于前两项之和。

我们假设n1是第一项，n2是第二项，最初n1=1,n2=1；然后n1=1,n2=2；再然后n1=2,n2=3;其实从第二个式子起n1等于前一次的n2，n2等于前一次的n1+n2，一直都是这个规律。

